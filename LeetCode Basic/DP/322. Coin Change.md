# Question
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
    
    Input: coins = [1, 2, 5], amount = 11
    Output: 3 
    Explanation: 11 = 5 + 5 + 1
Example 2:

    Input: coins = [2], amount = 3
    Output: -1

link: https://leetcode.com/problems/coin-change/
# Solution
状态转移方程为**min<sub>j=0…n−1</sub> = F(i−c<sub>j</sub>)+1**（如图所示），即是要注意现状态为前状态最少值推导而成,另外要注意dp数组要提前填充最大值。
![](https://assets.leetcode.com/static_assets/media/original_images/322_coin_change_table.png)
代码实现如下：
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(coins.length == 0)return -1;
        int n = coins.length;
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for(int i = 1;i <= amount;i++){
            for(int j = 0;j < n;j++){
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount?-1:dp[amount];
    }
}
```